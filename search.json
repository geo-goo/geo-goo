[{"title":"建立blog基于hexo","url":"/2024/05/18/blog/","content":"帮母亲煮饭后,突然觉得hexo上传到github pages应该没有很难\n写下这篇文章.\n"},{"title":"exotic options","url":"/2024/04/21/ref/financial/exotic_options/","content":"Exotic OptionsBarrier Optionsimport numpy as np# 设置参数S0 = 100.0         # 初始股票价格K = 100.0          # 行使价格T = 1.0            # 到期时间（年）r = 0.05           # 无风险利率sigma = 0.20       # 波动率B = 110            # 敲出屏障M = 50             # 时间步数dt = T / M         # 每个时间步的时间增量I = 10000          # 模拟路径数量# 模拟股票价格路径np.random.seed(0)  # 固定随机种子S = np.zeros((M + 1, I))S[0] = S0for t in range(1, M + 1):    z = np.random.standard_normal(I)    S[t] = S[t - 1] * np.exp((r - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * z)# 计算屏障期权的支付函数payoff = np.maximum(S[-1] - K, 0)# # 期权未被敲出# in_play = np.all(S &lt; B, axis=0)# print(in_play)# payoff = payoff * in_play# 蒙特卡洛估计期权价格C0 = np.exp(-r * T) * np.mean(payoff)print(f\"The price of the barrier call option is: {C0:.2f}\")\n\nKnock-out Option (up)import numpy as np# 设置参数S0 = 100.0         # 初始股票价格K = 100.0          # 行使价格T = 1.0            # 到期时间（年）r = 0.05           # 无风险利率sigma = 0.20       # 波动率B = 110            # 敲出屏障M = 50             # 时间步数dt = T / M         # 每个时间步的时间增量I = 10000          # 模拟路径数量# 模拟股票价格路径np.random.seed(0)  # 固定随机种子S = np.zeros((M + 1, I))S[0] = S0for t in range(1, M + 1):    z = np.random.standard_normal(I)    S[t] = S[t - 1] * np.exp((r - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * z)# 计算屏障期权的支付函数payoff = np.maximum(S[-1] - K, 0)# 期权未被敲出in_play = np.all(S &lt; B, axis=0)print(in_play)payoff = payoff * in_play# 蒙特卡洛估计期权价格C0 = np.exp(-r * T) * np.mean(payoff)print(f\"The price of the barrier call option is: {C0:.2f}\")\n\nKnock-in Option (up)import numpy as np# 设置参数S0 = 100.0         # 初始股票价格K = 100.0          # 行使价格T = 1.0            # 到期时间（年）r = 0.05           # 无风险利率sigma = 0.20       # 波动率B = 110            # 敲出屏障M = 50             # 时间步数dt = T / M         # 每个时间步的时间增量I = 10000          # 模拟路径数量# 模拟股票价格路径np.random.seed(0)  # 固定随机种子S = np.zeros((M + 1, I))S[0] = S0for t in range(1, M + 1):    z = np.random.standard_normal(I)    S[t] = S[t - 1] * np.exp((r - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * z)# 计算屏障期权的支付函数payoff = np.maximum(S[-1] - K, 0)# 期权未被敲出in_play = np.all(S &gt; B, axis=0)payoff = payoff * in_play# 蒙特卡洛估计期权价格C0 = np.exp(-r * T) * np.mean(payoff)print(f\"The price of the barrier call option is: {C0:.2f}\")\n\nKnock-out Options (down)import numpy as np# 设置参数S0 = 100.0         # 初始股票价格K = 100.0          # 行使价格T = 1.0            # 到期时间（年）r = 0.05           # 无风险利率sigma = 0.20       # 波动率B = 110            # 敲出屏障M = 50             # 时间步数dt = T / M         # 每个时间步的时间增量I = 10000          # 模拟路径数量# 模拟股票价格路径np.random.seed(0)  # 固定随机种子S = np.zeros((M + 1, I))S[0] = S0for t in range(1, M + 1):    z = np.random.standard_normal(I)    S[t] = S[t - 1] * np.exp((r - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * z)# 计算屏障期权的支付函数payoff = np.maximum(S[-1] - K, 0)# 期权未被敲出in_play = np.all(S &gt; B, axis=0)print(in_play)payoff = payoff * in_play# 蒙特卡洛估计期权价格C0 = np.exp(-r * T) * np.mean(payoff)print(f\"The price of the barrier call option is: {C0:.2f}\")\n\nKnock-in Options (down)import numpy as np# 设置参数S0 = 100.0         # 初始股票价格K = 100.0          # 行使价格T = 1.0            # 到期时间（年）r = 0.05           # 无风险利率sigma = 0.20       # 波动率B = 110            # 敲出屏障M = 50             # 时间步数dt = T / M         # 每个时间步的时间增量I = 10000          # 模拟路径数量# 模拟股票价格路径np.random.seed(0)  # 固定随机种子S = np.zeros((M + 1, I))S[0] = S0for t in range(1, M + 1):    z = np.random.standard_normal(I)    S[t] = S[t - 1] * np.exp((r - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * z)# 计算屏障期权的支付函数payoff = np.maximum(S[-1] - K, 0)# 期权未被敲出in_play = np.all(S &gt; B, axis=0)payoff = payoff * in_play# 蒙特卡洛估计期权价格C0 = np.exp(-r * T) * np.mean(payoff)print(f\"The price of the barrier call option is: {C0:.2f}\")","tags":["python"]},{"title":"mongodb","url":"/2024/04/21/ref/python/mongodb/","content":"使用mongodb进行连线.\n重点不是介绍怎么下载,而是注重于上传和输出.\nubuntu mongodb.mongodb-compassGUI for ubuntu.\nhttps://www.mongodb.com/try/download/compass\nmongodb-orghttps://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/\ndownload on here!\nmongodbsudo systemctl status mongod.service","tags":["python"]},{"title":"python 第三方教学档案","url":"/2024/04/18/ref/python/pythom_third_party_package/","content":"pandas.在Python中,可以使用where,mask来处理针对条件替换和过滤处理.# 创建一个示例DataFramedata = {'A': [1, 2, 3, 4, 5],        'B': [10, 20, 30, 40, 50]}df = pd.DataFrame(data)\n\nwhere.# 使用where方法筛选数据condition = df['A'] &gt; 2  # 创建筛选条件，这里选择'A'列中大于2的行result = df.where(condition, other=0)  # 不满足条件的行用0替换print(result)\n\noutput : \n     A     B0  0.0   0.01  0.0   0.02  3.0  30.03  4.0  40.04  5.0  50.0\n\nmask.# 使用mask方法筛选数据condition = df['A'] &gt; 2  # 创建筛选条件，这里选择'A'列中大于2的行result = df.mask(condition, other=0)  # 满足条件的行用0替换print(result)\n\noutput : \n   A   B0  1  101  2  202  0   03  0   04  0   0\n\n在Python中,可以使用apply来处理针对每个row或者column的处理.df = pd.DataFrame([[4, 9]] * 3, columns=['A', 'B'])df['C'] = df['B'].apply(lambda x : x*2)print(df)\n\noutput : \n   A  B   C0  4  9  181  4  9  182  4  9  18\n\n可以针对整个data frame.\ndf['params'] = df.apply(lambda x : model.optimization(                np.array([x['0.1'],x['0.25'],x['0.5'],x['0.75'],x['0.9']])/100,                x['forward'],                [x['0.1 strike'],x['0.25 strike'],x['0.5 strike'],x['0.75 strike'],x['0.9 strike']],                x['time'],beta),axis=1)\n\n在Python中,可以使用applymap来处理针对每个row或者column的处理.import pandas as pd# 示例DataFramedata = {'A': [True, False, True],        'B': [False, True, False]}df = pd.DataFrame(data)# 使用applymap和lambda将True和False转换为1和0df = df.applymap(lambda x: 1 if x else 0)print(df)\n\n   A  B0  1  01  0  12  1  0\n\nloguru.设定相对路径后添加日志.import os current_dir = os.path.dirname(os.path.abspath(__file__))logger = loguru_notf(current_dir)logger.add('te4st')try :    x , y = 1except Exception as e :   logger.error(f'error {e}.')\n\nmatplotlib.pyplot.设定 subplot.import matplotlib.pyplot as ptfrom matplotlib import stylestyle.use('ggplot')\n\n# 定义训练过程中的奖励和探索率列表rewards = [10, 15, 20, 25, 30, 35]  # 每个episode的累积奖励exploration_rates = [0.8, 0.6, 0.4, 0.2, 0.1, 0.05]  # 探索率（epsilon）# 绘制训练曲线pt.figure(figsize=(8, 3))pt.subplot(1,2,1)pt.plot(range(1, len(rewards) + 1), rewards, marker='x')pt.xlabel('Episode')pt.ylabel('Cumulative Reward')pt.title('Training Curve')pt.grid(True)# 绘制探索率变化pt.subplot(1,2,2)pt.plot(range(1, len(exploration_rates) + 1), exploration_rates, marker='x')pt.xlabel('Episode')pt.ylabel('Exploration Rate (epsilon)')pt.title('Exploration Rate Decay')pt.grid(True)pt.show()\n\n","tags":["python"]},{"title":"black scholes","url":"/2024/04/11/ref/black_scholes/black_scholes/","content":"\n\n基本假设\n资本市场是完美的,没有税或交易成本,股票价格没有上下限,任何股票可无线分割且无限卖空\n\n股票过程符合对数常态分配,即股票取对数后为常态分配\n\n无风险利率固定,股票报酬率的波动率是常数\n\n欧式选择权 , 只能到期日时履约\n\n标的股票不会违约\n\n股价是连续的, 不会有突发性股价跳空的情况发生\n\n\n比较简单的版本 : \n\n股价变动过程由Ito Process表示\n \n  ~ \n\n股价交易连续进行,且具可分割性\n\n不存在交易费用及税\n\n可无限放空,且充分利用放空资金\n\n无风险利率存在且为常数\n\n标的股在衍生性商品存续期间内不分配股利\n\n\n公式\n\n其中 : \n : 歐式買權目前價格\n : 標的資產目前價格\n : 歐式買權履約價格\n : 無風險利率 (以年為單位)\n : 股票報酬的波動度 (以年為單位)\n : 距到期日的時間長度 (以年為單位)\n\n隨機變數小於的纍積幾率總和,則\n\n\n為歐式買權價格對標的股票價格變動的敏感度 (稱爲 )\n\n其中 \n\n : 外国利率,股利\n : 資產價值的變動量\n : 標的股價S每變動1單位 , 歐式買權價值變動幅度剛好等於  。\n標的股價S每變動1單位对于选择权的价格的影响\n\n為避險比率或者視爲履約幾率 。\n\n\n\n建立在風險中立世界下, \n 選擇權被執行的概率，即 prob(S(T) &gt; K)\n\n\n 与  意义反映了期权内在价值与时间价值的综合影响。具体来说，它代表了股票价格在期权到期日时超过行使价格的概率。在购买期权（看涨或看跌）的情况下， 用于估算期权的delta值，即基础资产价格变动对期权价格的敏感度。\n 与 不同，直接关联到期权的内在价值，它代表了期权到期时内在价值为正（即对于看涨期权而言，股票价格高于行使价格；对于看跌期权而言，股票价格低于行使价格）的概率。因此， 是用来估计期权被行使的概率。\n简而言之， 和  通过结合当前股票价格、期权行使价格、时间价值、无风险利率以及股票价格的波动率，来计算期权的理论价值。这两个概率测度在期权定价中扮演着核心角色，有助于投资者评估期权的价值和风险。\n\nReferences[1] 期货与选择权策略型交易与套利实务, 廖四郎, 王昭文\n","tags":["python","financial"]},{"title":"python 进阶笔记","url":"/2024/04/18/ref/python/python/","content":"路径依赖.在Python中,可以直接设定工作目录.import os , syscurrent_dir = os.path.dirname(os.path.abspath(__file__))path = '/home/geo/Downloads/geo'sys.path.append(path)\n\nfrom notification_bot.telegram_chat import telegram_sendfrom notification_bot.loguru_notification import loguru_notffrom ml_bot.data_feature_eng import df_feature_eng , df_selectfrom ml_bot.data_reports import df_reportslogger = loguru_notf(current_dir)logger.add('bar_forecast_for_dep')filename = '{current_dir}/trade_data/ETHUSDT.csv'\n\n\n在在Python中,使用filter.# 定义一个函数，用于过滤条件def is_even(number):    return number % 2 == 0# 创建一个列表numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# 使用 filter 函数进行过滤filtered_numbers = filter(is_even, numbers)# 将结果转换为列表（在 Python 3 中 filter 返回的是迭代器）result_list = list(filtered_numbers)# 打印过滤后的列表print(result_list)\n\n函数.在Python中,使用lambda和def应用场景以及资源耗损.    语法形式：        lambda 函数是一种匿名函数，它使用简洁的语法形式定义，没有函数名，可以直接使用关键字 lambda，后跟参数列表和冒号，然后是表达式。例如：lambda x: x * 2。        def 函数是一种具名函数，需要使用关键字 def，后跟函数名、参数列表和冒号，然后是函数体。例如：def multiply(x): return x * 2。    简洁性：        lambda 函数适用于简单的函数逻辑，可以在一行代码中定义函数。        def 函数可以包含多行代码和复杂的逻辑。    可读性：        lambda 函数通常比较短小，适合用于简单的表达式或作为其他函数的参数。        def 函数具有函数名和函数体，可以提供更好的可读性和可维护性。    可调用性：        lambda 函数是表达式，可以直接在需要函数的地方调用，不需要定义函数名。        def 函数需要先定义，然后才能调用。    作用域：        lambda 函数的作用域只在其定义所在的表达式中，无法引用外部的变量。        def 函数可以访问并修改其所在作用域中的变量。总体来说，lambda 函数适用于简单的函数逻辑和一次性的使用场景，可以在需要时直接定义和调用，提供了更简洁的语法形式。def 函数则适用于复杂的逻辑和需要多次调用的函数，具有更好的可读性和可维护性。\n\n    内存消耗：        lambda 函数通常比较轻量级，因为它们只是一次性的表达式，不需要在内存中维护函数名和其他函数对象的属性。因此，每次调用 lambda 函数时，内存消耗较小。        def 函数在内存中维护函数对象，包括函数名、参数默认值、函数体等。每次调用 def 函数时，都需要创建函数对象，并占用额外的内存。    代码执行速度：        lambda 函数的执行速度通常比 def 函数略快，因为它们没有额外的函数查找和属性访问开销。        def 函数在执行时需要查找函数名，并且可能涉及属性访问等操作，导致略微的执行速度下降。然而，这些差别在实际情况中可能非常微小，并且可能在大部分应用中可以忽略不计。函数的资源消耗往往取决于函数体内部的操作和算法复杂度，而不仅仅取决于函数的定义方式。因此，在考虑性能问题时，更重要的是关注函数体内的实际逻辑和算法效率，而不仅仅是函数定义的形式。\n\n异常处理.在Python中,可以使用continue来ignore接下来的处理.a , b = [1,'2.',3,4,5,6] , [2,3,4,5,5,6] li = []for x , y in zip(a,b):    li.append((x,y))for ip , port in li :    try :        ip = ip.replace('.','s')    except Exception as e:        print(f'error : {e}')         continue    print(\"it's work.\")   \n\noutput : \nerror : 'int' object has no attribute 'replace'it's work.error : 'int' object has no attribute 'replace'error : 'int' object has no attribute 'replace'error : 'int' object has no attribute 'replace'error : 'int' object has no attribute 'replace'\n\ni/o在Python中,可以使用with解决读取文件.markdown_file_path = '/home/geo/Downloads/devscape/setup_bot/reports/input.md'with open(markdown_file_path,'r',encoding='utf-8') as f :    markdown_content = f.read()    elements = markdown_content.split('\\n')    for element in elements :        if element != '' :            print(element)","tags":["python"]},{"title":"python 想法笔记","url":"/2024/04/18/ref/python/python_medium/","content":"提供给中级者学习python的想法.\npython 中阶 ,    - class    - 数据处理 pandas , numpy    - 连接资料库 mongodb    - 日志系统    - 排程    - python资安    - 发送信息 gmail , telegram\n\nclass name :    def __init__(self):        ...    def func(self):        ...\n\nfrom dataclasses import dataclassclass name :    x : float    def func(self):        ...\n","tags":["python"]},{"title":"python 初学者教材","url":"/2024/04/18/ref/python/python_page/","content":"为了满足您对Python基础知识的需求，我会先创建一个详细的内容大纲，然后根据您的指示逐部分写作。这篇内容旨在为初学者提供一个全面的Python入门指南，覆盖从Python的历史背景到基本概念和实践应用的各个方面。请注意，这个大纲是为了确保内容的完整性和连贯性，但我可以根据您的具体需求进行调整。\n内容大纲\n引言\n\n简短介绍Python及其在软件开发和数据科学中的重要性。\n预计字数：100\n\n\nPython历史背景\n\nPython的起源和创始人Guido van Rossum的初衷。\nPython如何从一个圣诞节项目发展成为世界上最受欢迎的编程语言之一。\nPython2与Python3的主要区别及迁移。\n\n\nPython的基本概念\n\n语法特点：简洁明了的语法，易于学习和阅读。\n\n缩进作为语法的一部分。\n动态类型系统。\n预计字数：200\n\n\n基础数据类型和操作：数字（整型、浮点型）、字符串和布尔值。\n\n简单的示例代码。\n预计字数：200\n\n\n控制结构：条件语句、循环语句。\n\n使用示例解释 if , for 和 while 的用法。\n预计字数：200\n\n\n函数和模块：定义函数、参数传递、模块导入和使用。\n\n如何创建和使用Python函数。\n使用标准库模块进行文件操作、网络请求等。\n预计字数：200\n\n\n数据结构：列表、元组、字典和集合。\n\n操作和应用示例。\n预计字数：200\n\n\n\n\n实作应用\n\n简单的Python项目示例，如构建一个基本的计算器或数据分析项目。\n如何利用Python解决实际问题的思路和方法。\n预计字数：300\n\n\n结论\n\n总结Python的强大功能和灵活性。\n鼓励读者开始自己的Python学习之旅。\n预计字数：100\n\n\n\n总预计字数：1600\n这个大纲提供了一个全面的Python入门知识框架，从历史背景到实际应用都有覆盖。接下来，我将根据这个大纲开始写作第一部分：引言。如果您有任何修改意见或特定需求，请随时告诉我！\n引言Python，作为一门广泛应用于软件开发、网络服务器、机器学习、数据科学和自动化脚本的编程语言，因其高度的可读性和简单易学的特性而受到全球开发者的青睐。自从1991年首次发布以来，Python已经成为初学者入门编程的首选语言，同时也是许多专业开发者和数据科学家的重要工具。其设计哲学强调代码的可读性和简洁的语法，旨在帮助程序员以更少的代码行数完成更多的工作，同时保持代码的清晰和易于维护。Python的广泛应用范围从简单的日常任务自动化到复杂的机器学习算法实现，展现了其作为一门编程语言的强大能力和灵活性。\n接下来，我们将深入探讨Python的历史背景，了解它是如何从一个小型项目发展成为今天这样一个全球性的编程社区。我们也将覆盖Python编程的基本概念，包括其语法特点、基础数据类型、控制结构、函数和模块以及常用的数据结构，最后通过实际应用示例展示如何使用Python解决实际问题。\n\n下一部分将详细介绍Python历史背景，包括它的起源、发展历程以及Python2和Python3之间的主要区别。如果您对大纲有任何修改建议或想直接跳转到特定部分，请告诉我！\nPython历史背景起源与发展Python的创始人，Guido van Rossum，于1989年圣诞节期间开始着手开发Python，目标是创造一种既能够轻松读懂又能简单表达算法的新脚本解释器。Python的设计哲学是强调代码可读性和允许用户用较少的代码行数完成复杂的任务。这种设计哲学源自于Rossum对于其他编程语言的不满，特别是他希望改进当时在教育和研究领域广泛使用的ABC语言。\n1991年，Python 0.9.0版本首次公开发布，引入了异常处理、函数和模块的概念，这为Python后续的发展奠定了基础。随着社区的不断壮大和版本的迭代更新，Python逐渐增加了更多的特性，如列表理解、垃圾回收机制以及对复杂数据类型的支持。\nPython 2与Python 3Python 2.0于2000年发布，带来了许多重大更新，包括完全的垃圾回收和对Unicode的支持。然而，Python 2的广泛使用也导致了一些长期问题，特别是与新版本兼容性的问题。\nPython 3.0于2008年发布，被设计为更加清晰和一致的语言。尽管Python 3解决了许多Python 2存在的问题，但它不完全向后兼容。这意味着用Python 2编写的代码不一定能在Python 3环境中无缝运行，导致了长期的迁移过程。\n为了鼓励和帮助开发者从Python 2迁移到Python 3，Python社区和Python软件基金会提供了大量的资源和指南。2020年1月1日，Python 2正式停止支持，标志着Python社区全面转向Python 3。\n迁移与影响Python的发展不仅仅是语言本身的进步，更是一个广泛的、活跃的社区的共同努力。随着时间的推移，Python已经从一个简单的脚本语言发展成为了全球编程社区中最受欢迎和最有影响力的语言之一。它在数据科学、机器学习、网络开发、自动化和许多其他领域都有着广泛的应用。Python的成功故事证明了开源软件运动的力量，以及一个致力于创新和协作的社区可以如何塑造和推动技术的未来。\n\n接下来的部分将涵盖Python的基本概念，包括语法特点、数据类型、控制结构、函数、模块和数据结构等关键知识点。如果您准备好继续深入了解，或者有任何特定的问题或要求，请随时通知我。\nPython的基本概念\n语法特点\n\ndf.apply(lambda x : x['columns'] + 1 , axis = 1)\n\nlist(map(lambda f : f + 1 , (3,4)))\n\n\n基础数据类型和操作\n\n1 + 1&gt;&gt; 2\n\n1 - 1&gt;&gt; 0\n\n1 * 1&gt;&gt; 1\n\n2 ** 2&gt;&gt; 4\n\n需要看基础书籍确定是否正确.\n1 % 1&gt;&gt; 1\n\n\n控制结构\n\nx = 200if x in (200,300) :    print(x)else :     print('done')\n\nif (result := def f()) in (200,300) :     print(result)\n\nwhile True :    print('yes')\n\nfor _ in range(10) :    print(_)\n\nx = 'requests`match x :    case 'respone' :        print('no')    case 'requests' :        print('ok')\n\n\n函数和模块\n\ndef f():    return x**2\n\nf = lambda x : x**2\n\n\n数据结构\n\nimport pandas as pdimport numpy as npdf = np.array([1,2,3,4,5])print(df)\n\n实作应用在掌握了Python的基础知识之后，最好的学习方式之一是通过实践应用这些概念。下面，我们将通过两个简单的项目示例来展示如何使用Python解决实际问题：构建一个基本的计算器和一个简单的数据分析项目。\n1. 构建一个基本的计算器这个项目将展示如何使用Python的函数和基本数据类型来实现一个能够执行基础数学运算的计算器。\n步骤：\n定义函数：为加、减、乘、除创建四个函数，每个函数接收两个参数（数字），并返回它们的运算结果。\n\n用户输入：通过input()函数获取用户输入的数字和他们想要执行的操作（加、减、乘、除）。\n\n\ndf = input('database: ')print(df)\n\n\n执行运算并输出结果：根据用户选择的操作，调用相应的函数，并显示运算结果。\n\n示例代码：def add(x, y):    return x + ydef subtract(x, y):    return x - ydef multiply(x, y):    return x * ydef divide(x, y):    if y == 0:        return \"Error! Division by zero.\"    else:        return x / y# 用户输入print(\"Select operation:\")print(\"1.Add\")print(\"2.Subtract\")print(\"3.Multiply\")print(\"4.Divide\")choice = input(\"Enter choice(1/2/3/4): \")num1 = float(input(\"Enter first number: \"))num2 = float(input(\"Enter second number: \"))# 执行运算并输出结果if choice == '1':    print(num1, \"+\", num2, \"=\", add(num1, num2))elif choice == '2':    print(num1, \"-\", num2, \"=\", subtract(num1, num2))elif choice == '3':    print(num1, \"*\", num2, \"=\", multiply(num1, num2))elif choice == '4':    print(num1, \"/\", num2, \"=\", divide(num1, num2))else:    print(\"Invalid input\")\n\ndef add(x,y):    return x + ydef subtract(x,y):    return x - ydef multiply(x,y):    return x * ydef divide(x,y):    if y == 0:        return \"Error! Division by zero.\"    else:        return x / y# 用户输入print(\"Select operation:\")print(\"1.Add\")print(\"2.Subtract\")print(\"3.Multiply\")print(\"4.Divide\")choice = input(\"Enter choice(1/2/3/4): \")num1 = float(input(\"Enter first number: \"))num2 = float(input(\"Enter second number: \"))# 执行运算并输出结果match choice :    case 1 :        print(num1, \"+\", num2, \"=\", add(num1, num2))    case 2 :         print(num1, \"-\", num2, \"=\", subtract(num1, num2))    case 3 :        print(num1, \"*\", num2, \"=\", multiply(num1, num2))    case 4 :        print(num1, \"/\", num2, \"=\", divide(num1, num2))    case _ :        print(\"Invalid input\")\n\n2. 简单的数据分析项目在这个项目中，我们将使用Python来处理一组数据，并计算基本统计量，如平均值、中位数和标准差。\n步骤：\n数据准备：定义一个包含数值的列表。\n数据处理：编写函数来计算数据的平均值、中位数和标准差。\n结果展示：打印出计算结果，对数据集进行简单的分析。\n\n示例代码：import math# 数据准备data = [10, 20, 30, 40, 50]# 计算平均值def mean(data):    return sum(data) / len(data)# 计算中位数def median(data):    data.sort()    n = len(data)    mid = n // 2    if n % 2 == 0:        return (data[mid - 1] + data[mid]) / 2    else:        return data[mid]# 计算标准差def std_dev(data):    mu = mean(data)    variance = sum((x - mu) ** 2 for x in data) / len(data)    return math.sqrt(variance)# 结果展示print(\"Mean:\", mean(data))print(\"Median:\", median(data))print(\"Standard Deviation:\", std_dev(data))\n\n","tags":["python"]},{"title":"python re","url":"/2024/04/18/ref/python/python_re/","content":"Python re 模块教学\n简介Python的re模块提供了一系列功能强大的字符串操作功能，主要用于正则表达式匹配。通过这个模块，可以执行复杂的字符串分析和修改任务。\n基本概念\n正则表达式：一种特殊的字符串模式，用于在文本中查找符合某个标准的字符串。\n模式对象：使用re.compile()预编译正则表达式，提高匹配效率。\n匹配对象：使用模式对象进行匹配操作后返回的对象，包含匹配信息。\n\n常用函数\nre.match()\n\n作用：从字符串起始位置开始匹配正则表达式。\n示例代码：\n\nimport repattern = re.compile(r'\\d+')  # 匹配数字match = pattern.match('1234 is a number')if match:    print('Match found:', match.group())  # 输出匹配内容\n\nre.search()\n\n作用：扫描整个字符串并返回第一个成功的匹配。\n示例代码：\n\nimport repattern = re.compile(r'\\d+')search = pattern.search('Hello 1234 World')if search:    print('Search found:', search.group())\n\nre.findall()\n\n作用：找到字符串中所有匹配的子串，并以列表形式返回。\n示例代码：\n\nimport reresult = re.findall(r'\\d+', 'Hello 1234 World 5678')print('Numbers found:', result)\n\nre.sub()\n\n作用：替换字符串中的匹配项。\n示例代码：\n\nimport rereplaced_string = re.sub(r'\\d+', 'number', 'Hello 1234 World')print('Replaced String:', replaced_string)\n\n模式修饰符\n**re.I or re.IGNORECASE**：忽略大小写。\n**re.M or re.MULTILINE**：多行模式，影响^和$的行为。\n**re.S or re.DOTALL**：使.匹配包括换行在内的所有字符。\n\n高级用法\n分组：\n\n可以使用括号()来创建分组，这允许你单独提取部分匹配的字符串。\n示例代码：\n\nimport retext = \"John's phone number is 1234-5678\"pattern = re.compile(r'(\\d{4})-(\\d{4})')match = pattern.search(text)if match:    print('Area Code:', match.group(1))  # 第一个分组    print('Phone Number:', match.group(2))  # 第二个分组\n\n通过上述内容的学习，您应该能够掌握Python re模块的基础用法，对于更复杂的正则表达式技巧，建议在实践中逐渐学习和掌握。希望这份笔记能够帮助您更好地理解和使用Python的正则表达式功能。\n\n继续深入Python re模块的学习，我们将探讨一些更高级的正则表达式技术，包括正则表达式的特殊字符、非贪婪匹配以及使用命名分组。这部分内容将为您提供更多工具来处理复杂的文本处理任务。\n高级特性特殊字符在正则表达式中，有一些特殊字符具有特定的意义，了解它们是掌握正则表达式的关键。\n\n**.**：匹配除换行符以外的任何单个字符。\n**^**：匹配字符串的开头，在多行模式中匹配每行的开头。\n**$**：匹配字符串的末尾，在多行模式中匹配每行的末尾。\n*****：前一个字符的零次或多次匹配。\n**+**：前一个字符的一次或多次匹配。\n**?**：前一个字符的零次或一次匹配。\n**{m,n}**：前一个字符至少m次，最多n次的匹配。\n\n非贪婪匹配默认情况下，*, +, 和 ? 都是贪婪的匹配，这意味着它们会尽可能多地匹配文本。通过在这些字符后加上?，你可以实现非贪婪或最小匹配。\n\n示例代码：\n\nimport regreedy_match = re.findall(r'&lt;.*&gt;', '&lt;tag&gt;some text&lt;/tag&gt;')non_greedy_match = re.findall(r'&lt;.*?&gt;', '&lt;tag&gt;some text&lt;/tag&gt;')print('Greedy Match:', greedy_match)print('Non-greedy Match:', non_greedy_match)\n\n命名分组使用命名分组可以使得从正则表达式中提取信息变得更加清晰和方便。\n\n示例代码：\n\nimport repattern = re.compile(r'(?P&lt;area_code&gt;\\d{3})-(?P&lt;number&gt;\\d{7})')match = pattern.search('My number is 123-4567890')if match:    print('Area Code:', match.group('area_code'))    print('Number:', match.group('number'))\n\n前瞻与后顾前瞻（lookahead）和后顾（lookbehind）允许在不包括在匹配结果中的情况下，检查某些模式的前后是否存在某些模式。\n\n正向前瞻：(?=...)，断言此位置的后面能匹配括号内的表达式。\n\n负向前瞻：(?!...)，断言此位置的后面不能匹配括号内的表达式。\n\n正向后顾：(?&lt;=...)，断言此位置的前面能匹配括号内的表达式。\n\n负向后顾：(?&lt;!...)，断言此位置的前面不能匹配括号内的表达式。\n\n示例代码：\n\n\nimport retext = 'apple123'# Positive Lookaheadmatch = re.search(r'\\d+(?=\\d)', text)if match:    print('Positive Lookahead:', match.group())# Negative Lookaheadmatch = re.search(r'\\d+(?!\\d)', text)if match:    print('Negative Lookahead:', match.group())\n\n通过掌握这些高级技巧，您将能够更灵活地使用Python的re模块来处理各种复杂的文本数据。这将大大提升您在数据解析、清洗以及信息提取方面的能力。希望这些进阶知识能为您的笔记增添实用性。\n\n继续深入探讨Python re模块的高级功能，我们将讨论条件匹配、嵌套分组和模式的复合使用，这些都是在进行复杂文本处理时极为有用的高级技巧。\n高级功能继续条件匹配在正则表达式中，可以使用条件语句来根据前面的匹配结果决定后续的匹配规则。这通常结合前瞻和后顾来使用。\n\n示例代码：\n\nimport repattern = re.compile(r'(\\d{3})-(\\d{2})-(?(1)\\d{2}|\\d{3})')# 当第一组匹配到三个数字时，第三组需要匹配两个数字；如果没有匹配，需要匹配三个数字。match = pattern.match('123-45-67')if match:    print('Conditional Match:', match.groups())\n\n嵌套分组和复合使用正则表达式中的分组可以嵌套，允许构建复杂的匹配模式。同时，分组可以在正则表达式中重复使用，增加了表达式的灵活性。\n\n示例代码：\n\nimport repattern = re.compile(r'((\\d{3})-(\\d{3}))-(\\d{4})')match = pattern.match('123-456-7890')if match:    print('Nested Group Match:', match.groups())\n\n使用模式的复合在实际的应用场景中，经常需要将多个正则表达式组合使用，以适应不同的文本处理需求。\n\n示例代码：\n\nimport reemail_pattern = re.compile(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b')phone_pattern = re.compile(r'\\b\\d{3}-\\d{3}-\\d{4}\\b')text = \"Contact me at example@mail.com or 123-456-7890.\"email_match = email_pattern.search(text)phone_match = phone_pattern.search(text)if email_match:    print('Email found:', email_match.group())if phone_match:    print('Phone number found:', phone_match.group())\n\n最佳实践和性能提示使用Python re模块时，有几个最佳实践可以帮助提升性能和代码的可维护性：\n\n预编译正则表达式：对于频繁使用的正则表达式，预编译可以提升性能。\n使用原始字符串：在定义正则表达式时，使用原始字符串（如r\"text\"）可以避免Python解释器对字符串中特殊字符的处理。\n合理使用贪婪与非贪婪匹配：根据具体需求选择最适合的匹配模式，以避免不必要的性能开销。\n\n通过以上的高级技术和实用建议，您应该能够更有效地使用Python的re模块来处理各种复杂的文本任务。这些技能将为您在数据分析、自动化测试和其他许多领域提供强大的工具。希望这些信息能够丰富您的个人笔记，为未来的工作和学习提供帮助。\n","tags":["python"]},{"title":"volatility smile","url":"/2024/04/11/ref/volatility_smile/volatility_smile/","content":"基本观念平方根法制 : \n不确定性随着时间长度成平方根的增长 \n假设日报酬独立同分布(i.i.d)\nT天回报的标准差是日回报标准差的倍\n\n其中:\n\n\n为交易天数 \n\nRemark : 计算周五结束交易到下周一结束时股票价格的标准差时，我们发现，这“三天的连续复利收益率”并没有比连续两个交易日之间的连续复利收益率高很多，因此有种解释是波动率本身是由交易本身决定的，而累积的是不同交易日的“交易的不确定性”，因此我们更关心的是实际的交易天数(或者说波动率在交易日要远高于非交易日，因此在波动率计算中非交易日可以忽略不计)\n波动率类型分为两种 :  \n\n回望型波动率(backward looking)\n\n前沿波动率(forward looking)\n\n\n回顾波动率也就是所谓的历史波动率 , 发生了的历史价格波动率 \n前面所讨论的方法都默认过去各个时间点上的收益率对当前波动率的权重也就是贡献相同（equally weighted)，在实际中这往往不太现实，由于供求关系，市场环境，经济周期以及各种基本和技术层面的因素，波动率在不同时间区间往往会发生变化(regime switch), 很难想象1年前和1天前的收益率对估计波动率会有相同的影响。所以实际应用中往往需要对不同历史时刻的收益率施加不同的权重，这就有了一些更加复杂的波动率模型 , 如\nEWMA (Exponetially Weighted Moving Aveage) 检查\n其中  一般取为0.94左右。可以证明这样的模型使得历史收益率对波动率的影响随着过去距离今天的时间差而指数递减。\nGARCH (General Autoregressive Conditional Heteroskedastic Model)\n其中:\n\n\n\n\n\n收益率的残差(resuidual)\n\n\nE[残差] = 0 \n\n\n 为强白噪声过程 符合标准常态分布\n\n常用的模型为GARCH(1,1),也就是p=q=1 \n上面的EWMA是GARCH(1,1) 在  ,  时的特例。GARCH模型的一个优点在于它保证了当系数满足一定条件时波动率具有 mean reversion 的性质，也就是长期波动率存在一个稳定值。对GARCH(1,1), 这个值就是:\n\n条件是 \n此外还可以证明波动率满足GARCH模型的资产收益分布具有比常值波动率的高斯分布收益率更加厚的峰度（即heavy tail).\nGARCH 模型有很多变种，比如有时需要考虑同样绝对值的正负收益对波动率的不同影响。 我们做风险分析工作中用到的就有EGARCH， IGARCH以及GJR-GARCH等。\n前沿波动率根据现在的选择器价格,用B-S期权定价模型反推的波动率 , 对于未来一个价格的波动率推测\n隐含波动率implied volatility , 通过BS公式反解出来的  , 一般认为对未来波动率的预期 \n有人说 , implied volatility 的本质是一个错误的数字带入到错误的公式最终得到正确的价\n之后出现的 volatility smile/skew 也就不足为奇了。1987年以前，stock option呈现volatility smile \n87 股灾,也就是 LTCM 出事以后,volatility 就变成 skew 了,我们老师戏称其为中风病人的 smile\n不过在外汇市场上仍然是 smile 为主\n每一个期权价格都唯一的对应一个波动率,对于隐含波动率并没有明确的表达式，我们可以采用数值的方法来求\n按照期权定价模型来反推出所谓的前瞻型波动率，这个波动率又称为隐含波动率\n不同的执行价的隐含波动率是不同的，代表着交易员们对该股票未来波动率的看法\njohn hull 风险管理书有讨论波动率,很详细\n数据收集black scholes因为假设条件是常数.可分为 10-delta , 25-delta , ATM | 50-delta ,75-delta , 90-delta.\n通过三个商品求得上述5个点.\n显示隐含波动率的公式以及计算 10call,25call,ATM,25put,10put 的波动率计算.\nimport numpy as npimport matplotlib.pyplot as ptfrom scipy.stats import normfrom scipy.optimize import minimize# Heston model parametersr = 0.05  # risk-free ratev0, kappa, theta, sigma, rho = [3.994e-02, 2.070e+00, 3.998e-02, 1.004e-01, -7.003e-01]# Time to maturity and strike price ranges for the volatility surfaceT = np.linspace(0.1, 2, 20)  # Time to maturity from 0.1 to 2 yearsK = np.linspace(80, 120, 20)  # Strike prices from 80 to 120# Define a placeholder for the implied volatilitiesIV = np.zeros((len(T), len(K)))# Simplified method to estimate option prices under Heston model parametersdef simplified_option_price(S, K, T, r, kappa, theta, sigma, rho, v0):    \"\"\"A placeholder function to simulate option prices. Not an accurate representation of the Heston model.\"\"\"    return S * np.exp(-r * T) * norm.cdf((np.log(S / K) + (r + v0 / 2) * T) / np.sqrt(v0 * T))# Estimating implied volatility using a simplified method (placeholder)def estimate_iv(S, K, T, r, market_price):    \"\"\"Estimate implied volatility through numerical optimization.\"\"\"    objective = lambda iv: (simplified_option_price(S, K, T, r, kappa, theta, sigma, rho, iv) - market_price)**2    result = minimize(objective, 0.2, bounds=[(0.01, 1)])    return result.x[0]# Spot price of the underlying assetS = 100# Compute the market price of options across different strikes and maturitiesfor i, ti in enumerate(T):    for j, kj in enumerate(K):        market_price = simplified_option_price(S, kj, ti, r, kappa, theta, sigma, rho, v0)        IV[i, j] = estimate_iv(S, kj, ti, r, market_price)# Plotting the implied volatility surfaceT_mesh, K_mesh = np.meshgrid(T, K, indexing='ij')fig = pt.figure(figsize=(10, 7))ax = fig.add_subplot(111, projection='3d')surf = ax.plot_surface(T_mesh, K_mesh, IV, cmap='viridis')ax.set_xlabel('Time to Maturity')ax.set_ylabel('Strike Price')ax.set_zlabel('Implied Volatility')ax.set_title('Heston Model Implied Volatility Surface')pt.colorbar(surf)pt.show()\n\nimport numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D# Heston模型参数v0, kappa, theta, sigma, rho = [3.994e-02, 2.070e+00, 3.998e-02, 1.004e-01, -7.003e-01]# 时间和波动率的网格T = np.linspace(0.01, 2, 50) # 时间从0.01到2年V = np.linspace(0.01, 0.1, 50) # 波动率从0.01到0.1T, V = np.meshgrid(T, V)# 使用Heston模型中的波动率动态方程计算波动率的变化# 这里我们使用一个简化的形式来模拟波动率的变化，而不是完整的Heston模型Z = theta + (V - theta) * np.exp(-kappa * T)# 绘图fig = plt.figure()ax = fig.add_subplot(111, projection='3d')surf = ax.plot_surface(T, V, Z, cmap='viridis', edgecolor='none')ax.set_xlabel('Time to Maturity')ax.set_ylabel('Volatility')ax.set_zlabel('Price')ax.set_title('Simplified Volatility Surface under Heston Model')plt.colorbar(surf)plt.show()\"\"\"后续可以计算隐含波动率通过价格计算.\"\"\"\n\nReferences[1] https://zhuanlan.zhihu.com/p/85469506\n日志\n19-09-2020 , 把知乎的知识搬进来.\n14-04-2024 , volatility smile整理文件.\n\n","tags":["python","financial","implied volatility"]}]